---
sidebar_position: 3
---

import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

# Testing

In this guide, we will walk through the process of testing a Superfluid contract using the Foundry framework. We'll use the `FlowSender` contract described in the [Quickstart](/docs/protocol/quickstart.mdx) as our example to demonstrate how to write effective tests.

## Prerequisites

Before diving into testing your Superfluid contracts with Foundry, make sure you have set up your development environment properly. Here's a brief explanation of each step required:

1. **Creating and Navigating to Your Project Directory**:

    ```bash
    mkdir superfluid-example && cd superfluid-example
    ```

    This command creates a new directory named `foundry-example` and then changes your current working directory to it.

2. **Initializing a Foundry Project**:

   ```bash
   forge init
   ```

   This initializes a new Foundry project in your directory, setting up the necessary structure and configuration for Ethereum smart contract development.

3. **Installing Superfluid Protocol Dependencies**:

   ```bash
   forge install superfluid-protocol-monorepo=https://github.com/superfluid-finance/protocol-monorepo@dev --no-commit
   ```

   Installs the `dev`branch of the Superfluid protocol from its GitHub repository.

4. **Installing OpenZeppelin Contracts**:

   ```bash
   forge install https://github.com/OpenZeppelin/openzeppelin-contracts@v4.9.3 --no-commit
   ```

   Installs the necessary (4.9.3) of the OpenZeppelin contracts, which are widely used for secure smart contract development.

These steps ensure you have the necessary tools and dependencies installed to start developing and testing your Superfluid contracts with Foundry.

## Contract and Key Functions

<div>
<details>
<summary>Click here to show `FlowSender` contract</summary>
<p>

```solidity
//SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.14;

import { ISuperfluid, ISuperToken } from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol";

import { SuperTokenV1Library } from "@superfluid-finance/ethereum-contracts/contracts/apps/SuperTokenV1Library.sol";

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
// For deployment on Mumbai Testnet

interface IFakeDAI is IERC20 {

    function mint(address account, uint256 amount) external;

}

contract FlowSender {

    using SuperTokenV1Library for ISuperToken;
    
    mapping (address => bool) public accountList;

    ISuperToken public daix;

    // fDAIx address on Polygon Mumbai = 0x5D8B4C2554aeB7e86F387B4d6c00Ac33499Ed01f
    constructor(ISuperToken _daix) {

        daix = _daix;

    }

    /// @dev Mints 10,000 fDAI to this contract and wraps it all into fDAIx
    function gainDaiX() external {

        // Get address of fDAI by getting underlying token address from DAIx token
        IFakeDAI fdai = IFakeDAI( daix.getUnderlyingToken() );
        
        // Mint 10,000 fDAI
        fdai.mint(address(this), 10000e18);

        // Approve fDAIx contract to spend fDAI
        fdai.approve(address(daix), 20000e18);

        // Wrap the fDAI into fDAIx
        daix.upgrade(10000e18);

    }

    /// @dev creates a stream from this contract to desired receiver at desired rate
    function createStream(int96 flowRate, address receiver) external {

        // Create stream
        daix.createFlow(receiver, flowRate);

    }

    /// @dev updates a stream from this contract to desired receiver to desired rate
    function updateStream(int96 flowRate, address receiver) external {

        // Update stream
        daix.updateFlow(receiver, flowRate);

    }

    /// @dev deletes a stream from this contract to desired receiver
    function deleteStream(address receiver) external {

        // Delete stream
        daix.deleteFlow(address(this), receiver);

    }

    /// @dev get flow rate between this contract to certain receiver
    function readFlowRate(address receiver) external view returns (int96 flowRate) {
        
        // Get flow rate
        return daix.getFlowRate(address(this), receiver);

    }

}
```

</p>
</details>
</div>

- **gainDaiX**: Mints and wraps fDAI into fDAIx (Superfluid's wrapped token).
- **createStream**: Initiates a new money stream to a specified receiver.
- **updateStream**: Updates an existing money stream's flow rate.
- **deleteStream**: Terminates an existing money stream.
- **readFlowRate**: Reads the current flow rate of a stream.


## Writing Tests

### Setting Up Your Test Environment

Your test environment will depend on where you would like to test your Superfluid application. 
If you testing on a public testnet (e.g Polygon Mumbai), you do not need to deplot a new instance of the Superfluid protocol.
However, if you are testing on a local testnet you may want to deploy a new instance of the Superfluid protocol.

<Tabs
    defaultValue="testnet"
    values={[
        { label: 'Public Testnet', value: 'testnet' },
        { label: 'Local Net', value: 'localnet' },
    ]}
>

<TabItem value="testnet">

- Create a new Solidity file for your tests
- Import `forge-std/Test.sol` and inherit from `Test`.
- Import the Superfluid protocol contracts.
- Write your `setUp` function to run before each test case.

```solidity
pragma solidity ^0.8.14;
import "forge-std/Test.sol";
import {ISuperfluid} from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol";

contract FlowSenderTest is Test {
    // Test contract instance
    FlowSender flowSender;

    // Setup function to initialize test environment
    function setUp() public {
        // Initialize your contract here
        flowSender=FlowSender("YOUR_CONTRACT_ADDRESS_HERE");
        //if your contract is not deployed on the testnet yet, you can deploy it
        //flowSender=new FlowSender(FAKE_DAIX_CONTRACT_ADDRESS);
    }
}
```

</TabItem>
<TabItem value="localnet">
- Create a new Solidity file for your test.
- Import `forge-std/Test.sol` and inherit from `Test`.
- Import the Superfluid protocol contracts.
- Deploy a new instance of the Superfluid Protocol in the `setUp`function.
- Create and Deploy a new instance of your test contract.

```solidity
pragma solidity ^0.8.14;
import "forge-std/Test.sol";
import {ISuperfluid} from "@superfluid-finance/ethereum-contracts/contracts/interfaces/superfluid/ISuperfluid.sol";
import {SuperfluidFrameworkDeployer,
    TestGovernance,
    Superfluid,
    ConstantFlowAgreementV1,
    CFAv1Library,
    SuperTokenFactory
} from "@superfluid-finance/ethereum-contracts/contracts/utils/SuperfluidFrameworkDeployer.sol";


contract FlowSenderTest is Test {
    // Test contract instance
    FlowSender flowSender;
    //Set up your Superfluid framework
    struct Framework {
        TestGovernance governance;
        Superfluid host;
        ConstantFlowAgreementV1 cfa;
        CFAv1Library.InitData cfaLib;
        InstantDistributionAgreementV1 ida;
        IDAv1Library.InitData idaLib;
        SuperTokenFactory superTokenFactory;
    }

    SuperfluidFrameworkDeployer.Framework sf;

    // Setup function to initialize test environment
    function setUp() public {
        address public owner;
	    //DEPLOYING THE FRAMEWORK
        SuperfluidFrameworkDeployer sfDeployer = new SuperfluidFrameworkDeployer();
        sf = sfDeployer.getFramework();
				
	    // DEPLOYING DAI and DAI wrapper super token

	    ISuperToken daix = sfDeployer.deployWrapperToken(
	    "Fake DAI", "DAI", 18, 10000000000000
	    );

        // Initialize your contract here
        flowSender = new FlowSender(
            daix
        );

    }
}
```
</TabItem>
</Tabs>

:::tip About the `setUp` Function
The `setUp` function is an **optional** function standardized by Foundry (but it is necessary here, especially in the case of local testnet). It is a special function that is executed before each test case. It is used to initialize the test environment and contract instances.
To learn more about the `setUp` function, check out the [Foundry documentation](https://book.getfoundry.sh/forge/writing-tests).
:::
